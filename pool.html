<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Two-Player Pool â€” Play</title>
<style>
  :root{
    --bg:#07120b;
    --felt:#0d6b35;
    --rail:#5a3d24;
    --panel:#fff8;
    --accent:#1e8cff;
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,sans-serif;background:var(--bg);color:#fff}
  .wrap{display:flex;gap:18px;padding:18px;align-items:flex-start;justify-content:center}
  canvas{border-radius:12px;border:12px solid var(--rail);box-shadow:0 18px 60px rgba(0,0,0,0.7);background:var(--felt);display:block}
  .panel{width:320px;background:#ffffff11;color:#e9fbf0;border-radius:10px;padding:14px;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
  h3{margin:6px 0 8px;color:#dff}
  .muted{font-size:13px;color:#bfe;margin-top:6px}
  .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  button{padding:8px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
  .btn-primary{background:var(--accent);color:white}
  .small{font-size:12px;color:#cfe;margin-top:10px}
  .scoreboard{margin-top:12px;padding:8px;background:#ffffff22;border-radius:8px;font-size:14px}
  .turn{font-weight:bold;color:#aaffaa}
  table{width:100%;font-size:13px;border-collapse:collapse}
  td,th{padding:6px;border-bottom:1px solid rgba(255,255,255,0.03)}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .legend span{padding:6px 8px;border-radius:6px;background:#ffffff22;color:#eaffea;font-weight:700}
  .footer-note{font-size:12px;color:#cfe;margin-top:10px}
</style>
</head>
<body>
<div class="wrap" style="align-items:flex-start">
  <canvas id="table" width="920" height="520"></canvas>

  <div class="panel" aria-label="controls">
    <h3>Two-Player Pool</h3>
    <div class="muted">Click & drag the white cue ball to aim. Release to shoot. Pocket a ball â†’ gain a point and keep turn. Miss â†’ turn switches. Cue scratched â†’ turn switches.</div>

    <div class="scoreboard" aria-live="polite">
      <div>ðŸŽ± <b>Player 1:</b> <span id="p1Score">0</span></div>
      <div>ðŸŽ± <b>Player 2:</b> <span id="p2Score">0</span></div>
      <div style="margin-top:6px;">Turn: <span id="turnName" class="turn">Player 1</span></div>
    </div>

    <div class="controls">
      <button id="reset" class="btn-primary">Reset All</button>
      <button id="reposition">Re-rack</button>
      <button id="toggleAIM">Toggle Aim Lines</button>
    </div>

    <div class="small" id="hoverInfo">Hover: â€”</div>

    <h3 style="margin-top:12px">Legend</h3>
    <div class="legend">
      <span style="background:#ffffffaa;color:#000">Cue</span>
      <span style="background:#ffd54faa;color:#000">Target</span>
      <span style="background:#ffffff22;color:#fff">Aim line</span>
      <span style="background:#00ff00aa;color:#000">Pocket line</span>
    </div>

    <div class="footer-note">This is a client-only demo. For real multiplayer and persistent stats you need a server (Socket.io) â€” I can add that later.</div>
  </div>
</div>

<script>
/* Two-player Pool â€” client only
   - Click cue ball to start aiming, drag cursor away to set power, release to shoot.
   - Two-player hotseat scoring.
   - Elastic collisions, friction, pockets.
*/

// Canvas and context
const canvas = document.getElementById('table');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// UI elements
const resetBtn = document.getElementById('reset');
const repositionBtn = document.getElementById('reposition');
const toggleAIMBtn = document.getElementById('toggleAIM');
const hoverInfo = document.getElementById('hoverInfo');
const p1ScoreEl = document.getElementById('p1Score');
const p2ScoreEl = document.getElementById('p2Score');
const turnName = document.getElementById('turnName');

let showAim = true;

// Table constants
const POCKET_R = 28;
const BALL_R = 14;
const FRICTION = 0.993;
const WALL_BOUNCE = 0.92;
const POWER_FACTOR = 0.32;

// Pockets positions
const POCKETS = [
  {x:0, y:0},
  {x:W/2, y:0},
  {x:W, y:0},
  {x:0, y:H},
  {x:W/2, y:H},
  {x:W, y:H}
];

// ball colors
const COLORS = {
  0:'#ffffff', 1:'#ffd54f',2:'#2196f3',3:'#e53935',4:'#8e44ad',5:'#ff9800',
  6:'#4caf50',7:'#8b0000',8:'#000000',9:'#ffd54f',10:'#2196f3',11:'#e53935',
  12:'#8e44ad',13:'#ff9800',14:'#4caf50',15:'#8b0000'
};

// Game state
let balls = [];   // Ball objects
let cue = null;   // pointer to cue ball
let aiming = false;
let mouse = {x:0,y:0};
let shotInProgress = false;
let players = [{name:'Player 1',score:0},{name:'Player 2',score:0}];
let currentPlayer = 0;

// Helper â€” distance
function dist(ax,ay,bx,by){
  const dx = bx-ax, dy = by-ay;
  return Math.hypot(dx,dy);
}

// Ball class
class Ball {
  constructor(x,y,num){
    this.x = x; this.y = y; this.num = num; this.r = BALL_R;
    this.color = COLORS[num] || '#999';
    this.vx = 0; this.vy = 0; this.inPocket = false;
    this.isCue = (num === 0);
  }
  draw(){
    if(this.inPocket) return;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#0a0a0a55';
    ctx.stroke();
    // number for non-cue
    if(!this.isCue){
      ctx.fillStyle = '#fff';
      ctx.font = ${this.r}px Arial;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(this.num, this.x, this.y);
    } else {
      // small mark on cue
      ctx.fillStyle = '#eee';
      ctx.beginPath(); ctx.arc(this.x,this.y,this.r*0.14,0,Math.PI*2); ctx.fill();
    }
  }
  update(){
    if(this.inPocket) return;
    this.x += this.vx; this.y += this.vy;
    this.vx *= FRICTION; this.vy *= FRICTION;
    if(Math.abs(this.vx) < 0.02) this.vx = 0;
    if(Math.abs(this.vy) < 0.02) this.vy = 0;
    // walls
    if(this.x - this.r < 0){ this.x = this.r; this.vx *= -WALL_BOUNCE; }
    if(this.x + this.r > W){ this.x = W - this.r; this.vx *= -WALL_BOUNCE; }
    if(this.y - this.r < 0){ this.y = this.r; this.vy *= -WALL_BOUNCE; }
    if(this.y + this.r > H){ this.y = H - this.r; this.vy *= -WALL_BOUNCE; }
    // pockets
    for(const p of POCKETS){
      const d = dist(this.x,this.y,p.x,p.y);
      if(d < POCKET_R - this.r*0.2){
        this.inPocket = true;
        this.vx = 0; this.vy = 0;
      }
    }
  }
}

// Create rack (triangle) and cue
function rackCenter(){
  balls = [];
  const centerX = W/2 + 80; // rack on right half visually
  const centerY = H/2;
  // cue on left
  cue = new Ball(160, centerY, 0);
  balls.push(cue);
  let n = 1;
  // standard 5-row triangle (15 balls)
  const rows = 5;
  for(let row=0; row<rows; row++){
    for(let col=0; col<=row; col++){
      const x = centerX - row*(BALL_R*2 + 1);
      const y = centerY + (col - row/2)*(BALL_R*2 + 1);
      balls.push(new Ball(x,y,n));
      n++;
      if(n>15) break;
    }
  }
}

// Collision resolution between two balls (elastic, equal mass)
function resolveCollisions(){
  for(let i=0;i<balls.length;i++){
    for(let j=i+1;j<balls.length;j++){
      const A = balls[i], B = balls[j];
      if(A.inPocket || B.inPocket) continue;
      const dx = B.x - A.x, dy = B.y - A.y;
      const distAB = Math.hypot(dx,dy);
      const minDist = A.r + B.r;
      if(distAB < minDist && distAB > 0.0001){
        // push apart
        const nx = dx / distAB, ny = dy / distAB;
        const overlap = minDist - distAB;
        A.x -= nx * overlap/2; A.y -= ny * overlap/2;
        B.x += nx * overlap/2; B.y += ny * overlap/2;
        // resolve velocity along normal
        const dvx = A.vx - B.vx, dvy = A.vy - B.vy;
        const impact = dvx * nx + dvy * ny;
        if(impact > 0){
          const impulse = impact;
          A.vx -= impulse * nx; A.vy -= impulse * ny;
          B.vx += impulse * nx; B.vy += impulse * ny;
        }
      }
    }
  }
}

// Predict pocket for a target ball given incoming vector (approx)
function predictPocketForTarget(target, incomingVec){
  let best = null;
  const incAngle = Math.atan2(incomingVec.y, incomingVec.x);
  for(const p of POCKETS){
    const vx = p.x - target.x, vy = p.y - target.y;
    const mag = Math.hypot(vx,vy);
    if(mag < 1) continue;
    const angle = Math.abs(normalizeAngle(Math.atan2(vy,vx) - incAngle));
    if(angle > 1.05) continue; // > ~60deg ignore
    const blocked = isSegmentBlocked(target.x, target.y, p.x, p.y, target);
    if(blocked) continue;
    const score = angle + (mag/1000);
    if(!best || score < best.score) best = {p,score};
  }
  return best ? best.p : null;
}

function normalizeAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return Math.abs(a);
}

// check if segment AB is blocked by any ball other than ignore
function segIntersectsCircle(ax,ay,bx,by,cx,cy,r){
  const vx = bx-ax, vy = by-ay;
  const wx = cx-ax, wy = cy-ay;
  const c1 = vx*wx + vy*wy;
  if(c1 <= 0) return Math.hypot(cx-ax,cy-ay) <= r;
  const c2 = vx*vx + vy*vy;
  if(c2 <= c1) return Math.hypot(cx-bx,cy-by) <= r;
  const t = c1 / c2;
  const px = ax + t*vx, py = ay + t*vy;
  return Math.hypot(cx-px,cy-py) <= r;
}

function isSegmentBlocked(ax,ay,bx,by, ignoreBall){
  for(const b of balls){
    if(b === ignoreBall || b.inPocket) continue;
    if(segIntersectsCircle(ax,ay,bx,by,b.x,b.y,b.r - 1)) return true;
  }
  return false;
}

// Draw pockets with rim
function drawPockets(){
  for(const p of POCKETS){
    ctx.beginPath();
    ctx.arc(p.x,p.y,POCKET_R+6,0,Math.PI*2);
    ctx.fillStyle = '#3b2b20'; ctx.fill();
    ctx.beginPath(); ctx.arc(p.x,p.y,POCKET_R-6,0,Math.PI*2);
    const g = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,POCKET_R-6);
    g.addColorStop(0,'#00000088'); g.addColorStop(1,'#000000ff');
    ctx.fillStyle = g; ctx.fill();
  }
}

// Check if all balls stopped (or pocketed)
function allStopped(){
  return balls.every(b => b.inPocket || (Math.abs(b.vx) < 0.01 && Math.abs(b.vy) < 0.01));
}

// Render loop
let hoverTarget = null;
function render(){
  // physics update
  for(const b of balls) b.update();
  resolveCollisions();

  // background felt
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#0c6b36';
  ctx.fillRect(0,0,W,H);

  drawPockets();

  // aims & predictive visuals when aiming
  if(aiming && !shotInProgress && showAim){
    // line from cue to mouse
    ctx.beginPath(); ctx.moveTo(cue.x, cue.y); ctx.lineTo(mouse.x, mouse.y);
    ctx.strokeStyle = 'rgba(255,255,255,0.16)'; ctx.lineWidth = 2; ctx.setLineDash([8,6]); ctx.stroke(); ctx.setLineDash([]);

    // visible targets from cue
    const candidates = balls.filter(b => !b.inPocket && !b.isCue);
    const visible = [];
    for(const t of candidates){
      const blocked = isSegmentBlocked(cue.x,cue.y,t.x,t.y,t);
      if(!blocked){
        visible.push(t);
        ctx.beginPath(); ctx.moveTo(cue.x,cue.y); ctx.lineTo(t.x,t.y);
        ctx.strokeStyle = 'rgba(255,255,255,0.28)'; ctx.lineWidth = 1.2; ctx.stroke();
      }
    }

    // find hover target (closest to mouse among visible)
    let best = null; let bestD = 1e9;
    for(const t of visible){
      const d = dist(t.x,t.y,mouse.x,mouse.y);
      if(d < bestD){ bestD = d; best = t; }
    }
    hoverTarget = best || null;
    hoverInfo.textContent = hoverTarget ? Hovering target: #${hoverTarget.num} : 'Hovering target: â€”';

    // highlight hovered and show predicted pocket
    for(const t of visible){
      if(t === hoverTarget){
        ctx.beginPath(); ctx.arc(t.x,t.y,t.r+6,0,Math.PI*2); ctx.strokeStyle='rgba(255,215,0,0.95)'; ctx.lineWidth=3; ctx.stroke();
        // predict pocket
        const incoming = {x: t.x - cue.x, y: t.y - cue.y};
        const mag = Math.hypot(incoming.x,incoming.y);
        if(mag > 0.001){
          const incVec = {x:incoming.x/mag, y:incoming.y/mag};
          const pocket = predictPocketForTarget(t, incVec);
          if(pocket){
            ctx.beginPath(); ctx.moveTo(t.x,t.y); ctx.lineTo(pocket.x,pocket.y);
            ctx.strokeStyle = 'rgba(0,255,120,0.95)'; ctx.lineWidth=2.6; ctx.setLineDash([8,6]); ctx.stroke(); ctx.setLineDash([]);
            ctx.beginPath(); ctx.arc(pocket.x,pocket.y,8,0,Math.PI*2); ctx.fillStyle='rgba(0,255,120,0.95)'; ctx.fill();
          } else {
            ctx.beginPath(); ctx.moveTo(t.x-6,t.y-6); ctx.lineTo(t.x+6,t.y+6); ctx.moveTo(t.x-6,t.y+6); ctx.lineTo(t.x+6,t.y-6);
            ctx.strokeStyle='rgba(255,0,0,0.8)'; ctx.lineWidth=1.6; ctx.stroke();
          }
        }
      }
    }
  } else {
    hoverTarget = null;
    hoverInfo.textContent = 'Hovering target: â€”';
  }

  // draw balls
  for(const b of balls) b.draw();

  // when shot finished: if all stopped and shotInProgress was true -> decide turn change
  if(shotInProgress){
    if(allStopped()){
      shotInProgress = false;
      // if any non-cue ball pocketed this shot? that logic handled in update loop when pocketing occurs
      // If no ball pocketed by shooter, then switch turn (we tracked pocketed flags earlier)
      if(!lastShot.scored){
        switchTurn();
      } else {
        // player keeps turn
      }
      // reset lastShot flags
      lastShot.scored = false;
      lastShot.cuePocketed = false;
    }
  }

  requestAnimationFrame(render);
}

// Shot bookkeeping for turn logic
let lastShot = {scored:false, cuePocketed:false};

// Shoot: compute velocity from drag (cue->mouse)
function shootFromDrag(){
  if(!aiming || shotInProgress) return;
  const dx = mouse.x - cue.x, dy = mouse.y - cue.y;
  const d = Math.hypot(dx,dy);
  if(d < 6) { aiming=false; return; }
  // direction from cue to mouse -> shooter pulls back opposite direction; we'll shoot toward mouse
  const ux = dx / d, uy = dy / d;
  const pull = Math.min(160, d);
  cue.vx = ux * (pull * POWER_FACTOR);
  cue.vy = uy * (pull * POWER_FACTOR);
  shotInProgress = true;
  aiming = false;
  lastShot.scored = false;
  lastShot.cuePocketed = false;
}

// Mouse events
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top;
});

canvas.addEventListener('mousedown', e => {
  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left, my = e.clientY - r.top;
  if(dist(mx,my,cue.x,cue.y) <= cue.r + 10 && !shotInProgress && allStopped()){
    aiming = true;
  }
});

canvas.addEventListener('mouseup', e => {
  if(aiming && !shotInProgress) shootFromDrag();
  aiming = false;
});

// Touch support
canvas.addEventListener('touchstart', e => {
  const t = e.touches[0];
  const r = canvas.getBoundingClientRect();
  const mx = t.clientX - r.left, my = t.clientY - r.top;
  if(dist(mx,my,cue.x,cue.y) <= cue.r + 12 && !shotInProgress && allStopped()){
    aiming = true;
  }
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchmove', e => {
  const t = e.touches[0];
  const r = canvas.getBoundingClientRect();
  mouse.x = t.clientX - r.left; mouse.y = t.clientY - r.top;
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', e => {
  if(aiming && !shotInProgress) shootFromDrag();
  aiming=false;
  e.preventDefault();
}, {passive:false});

// When any ball goes into pocket during update, update player score and flags
function checkPocketEvents(){
  for(const b of balls){
    if(b.inPocket && !b._alreadyPocketed){
      b._alreadyPocketed = true;
      // if cue pocketed
      if(b.isCue){
        lastShot.cuePocketed = true;
        // cue scratched -> switch turn and reposition cue
        switchTurn();
        setTimeout(()=>{ repositionCue(); }, 600);
      } else {
        // normal ball pocketed -> increment current player's score and keep turn
        players[currentPlayer].score += 1;
        updateScores();
        lastShot.scored = true;
      }
    }
  }
}

// reposition cue if scratched: move cue to safe spot (left center) not overlapping
function repositionCue(){
  cue.inPocket = false;
  // find safe position left center
  const startX = 160, startY = H/2;
  cue.x = startX; cue.y = startY;
  cue.vx = 0; cue.vy = 0;
  // ensure not overlapping other balls; nudged if necessary
  for(const b of balls){
    if(b === cue || b.inPocket) continue;
    const d = dist(cue.x,cue.y,b.x,b.y);
    if(d < cue.r + b.r + 4){
      cue.x -= (cue.r + b.r + 6);
    }
  }
}

// switch player turn
function switchTurn(){
  currentPlayer = 1 - currentPlayer;
  turnName.textContent = players[currentPlayer].name;
}

// update scoreboard elements
function updateScores(){
  p1ScoreEl.textContent = players[0].score;
  p2ScoreEl.textContent = players[1].score;
}

// Reset table fully (scores too)
function resetAll(){
  players[0].score = 0; players[1].score = 0;
  currentPlayer = 0; turnName.textContent = players[currentPlayer].name;
  rackCenter();
  updateScores();
  shotInProgress = false; aiming = false;
}

// Re-rack (keep scores)
function reRack(){
  currentPlayer = 0; turnName.textContent = players[currentPlayer].name;
  players[0].score = players[0].score; players[1].score = players[1].score;
  rackCenter();
  updateScores();
}

// event listeners for UI
resetBtn.addEventListener('click', ()=>{ if(confirm('Reset table and scores?')) resetAll(); });
repositionBtn.addEventListener('click', ()=>{ if(confirm('Re-rack balls?')) reRack(); });
toggleAIMBtn.addEventListener('click', ()=>{ showAim = !showAim; toggleAIMBtn.textContent = showAim ? 'Hide Aim Lines' : 'Show Aim Lines'; });

// small loop to check pocket events each frame
setInterval(checkPocketEvents, 120);

// initialize and start rendering
rackCenter();
updateScores();
render();

</script>
</body>
</html>
